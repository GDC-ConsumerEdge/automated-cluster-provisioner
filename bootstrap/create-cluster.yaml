steps:

- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  id: Read cluster intent, create cluster, and configure configsync
  script: |
    #!/usr/bin/env bash
    set +x

    HARDWARE_MANAGMENT_API_ENDPOINT="https://gdchardwaremanagement.googleapis.com"
    if [[ -n "${HARDWARE_MANAGMENT_API_ENDPOINT_OVERRIDE}" ]]; then
      HARDWARE_MANAGMENT_API_ENDPOINT=${HARDWARE_MANAGMENT_API_ENDPOINT_OVERRIDE}
    fi
    HARDWARE_MANAGMENT_API_VERSION="v1alpha"

    function die() {
      echo "Cluster Creation Failed: $1"
      exit 1
    }

    function zone_signal_complete() {
      zone_store_path=$1
      [[ -z "${zone_store_path}" ]] && { echo "zone_store_path not provided"; return ; }

      SIGNAL_URI="${HARDWARE_MANAGMENT_API_ENDPOINT}/${HARDWARE_MANAGMENT_API_VERSION}/${zone_store_path}:signal"
      out=$(curl -f -H "Authorization: Bearer $(gcloud auth print-access-token)" \
            -H "Content-Type: application/json" \
            -X POST \
            "${SIGNAL_URI}" \
            -d '{"state_signal": "READY_FOR_SITE_TURNUP"}')
      if [[ $? -ne 0 ]]; then
        echo "Failed to signal the zone state"
        return 1
      fi
      
      operation_id=$(echo $out | jq -r .name)
      URI="${HARDWARE_MANAGMENT_API_ENDPOINT}/${HARDWARE_MANAGMENT_API_VERSION}/${operation_id}"
      count=0
      max_retries=10
      while [[ ${count} -lt ${max_retries} ]]; do
        is_completed=$(curl -s -H "Authorization: Bearer $(gcloud auth print-access-token)" \
            "${URI}" | jq -r .done)
        [[ "${is_completed}" != "false" ]] && break
      done
    
    }

    [[ -z "${STORE_ID}" ]] && die "STORE_ID not set"

    NODE_LOCATION=${ZONE}
    [[ -z "$NODE_LOCATION" ]] && die "ZONE not set"

    apt-get update
    apt-get install -y gettext-base
    apt-get install -y csvtool
    apt-get install -y jq

    TOKEN=$(gcloud secrets versions access latest --secret=$GIT_SECRET_ID --project $GIT_SECRETS_PROJECT_ID)
    git clone -b $SOURCE_OF_TRUTH_BRANCH https://oauth2:$TOKEN@$SOURCE_OF_TRUTH_REPO repo
    cp repo/$SOURCE_OF_TRUTH_PATH ./cluster-intent-registry.csv

    export CLUSTER_INTENT_ROW=$(awk -F , "\$1 == \"$STORE_ID\" || \$1 == \"\\\"$STORE_ID\\\"\"" cluster-intent-registry.csv)
    echo $CLUSTER_INTENT_ROW
    [[ -z "$CLUSTER_INTENT_ROW" ]] && die "Cluster intent not found for store $STORE_ID"
    export CLUSTER_INTENT_HEADER=$(head -1 cluster-intent-registry.csv)
    export CLUSTER_INTENT="$CLUSTER_INTENT_HEADER"$'\n'"$CLUSTER_INTENT_ROW"


    # Set parameters from cluster intent
    export MACHINE_PROJECT_ID=$(echo "$CLUSTER_INTENT" | csvtool namedcol "machine_project_id" - | csvtool drop 1 -)
    export FLEET_PROJECT_ID=$(echo "$CLUSTER_INTENT" | csvtool namedcol "fleet_project_id" - | csvtool drop 1 -)
    export CLUSTER_NAME=$(echo "$CLUSTER_INTENT" | csvtool namedcol "cluster_name" - | csvtool drop 1 -)
    export LOCATION=$(echo "$CLUSTER_INTENT" | csvtool namedcol "location" - | csvtool drop 1 -)
    export NODE_COUNT=$(echo "$CLUSTER_INTENT" | csvtool namedcol "node_count" - | csvtool drop 1 -)
    export CLUSTER_IPV4_CIDR=$(echo "$CLUSTER_INTENT" | csvtool namedcol "cluster_ipv4_cidr" - | csvtool drop 1 -)
    export SERVICES_IPV4_CIDR=$(echo "$CLUSTER_INTENT" | csvtool namedcol "services_ipv4_cidr" - | csvtool drop 1 -)
    export EXTERNAL_LOAD_BALANCER_IPV4_ADDRESS_POOLS=$(echo "$CLUSTER_INTENT" | csvtool namedcol "external_load_balancer_ipv4_address_pools" - | csvtool drop 1 -)
    export SYNC_REPO=$(echo "$CLUSTER_INTENT" | csvtool namedcol "sync_repo" - | csvtool drop 1 -)
    export SYNC_BRANCH=$(echo "$CLUSTER_INTENT" | csvtool namedcol "sync_branch" - | csvtool drop 1 -)
    export SYNC_DIR=$(echo "$CLUSTER_INTENT" | csvtool namedcol "sync_dir" - | csvtool drop 1 -)
    export SECRETS_PROJECT_ID=$(echo "$CLUSTER_INTENT" | csvtool namedcol "secrets_project_id" - | csvtool drop 1 -)
    export GIT_TOKEN_SECRETS_MANAGER_NAME=$(echo "$CLUSTER_INTENT" | csvtool namedcol "git_token_secrets_manager_name" - | csvtool drop 1 -)
    export ES_AGENT_SECRETS_MANAGER_NAME=$(echo "$CLUSTER_INTENT" | csvtool namedcol "es_agent_secrets_manager_name" - | csvtool drop 1 -)
    export CLUSTER_VERSION=$(echo "$CLUSTER_INTENT" | csvtool namedcol "cluster_version" - | csvtool drop 1 -)
    export MAINTENANCE_WINDOW_START=$(echo "$CLUSTER_INTENT" | csvtool namedcol "maintenance_window_start" - | csvtool drop 1 -)
    export MAINTENANCE_WINDOW_END=$(echo "$CLUSTER_INTENT" | csvtool namedcol "maintenance_window_end" - | csvtool drop 1 -)
    export MAINTENANCE_WINDOW_RECURRENCE=$(echo "$CLUSTER_INTENT" | csvtool namedcol "maintenance_window_recurrence" - | csvtool drop 1 -)
    export SUBNET_VLANS=$(echo "$CLUSTER_INTENT" | csvtool namedcol "subnet_vlans" - | csvtool drop 1 - | tr -d '"')
    export ZONE_NAME_FROM_SOT=$(echo "$CLUSTER_INTENT" | csvtool namedcol "zone_name" - | csvtool drop 1 -)

    if [ -n "${EDGE_CONTAINER_API_ENDPOINT_OVERRIDE:-}" ]; then
      echo "Setting api_endpoint_overrides/edgecontainer to $EDGE_CONTAINER_API_ENDPOINT_OVERRIDE"
      gcloud config set api_endpoint_overrides/edgecontainer $EDGE_CONTAINER_API_ENDPOINT_OVERRIDE
    fi

    if [ -n "${GKEHUB_API_ENDPOINT_OVERRIDE:-}" ]; then
      echo "Setting api_endpoint_overrides/gkehub to $GKEHUB_API_ENDPOINT_OVERRIDE"
      gcloud config set api_endpoint_overrides/gkehub $GKEHUB_API_ENDPOINT_OVERRIDE
    fi

    if [ -n "${EDGE_NETWORK_API_ENDPOINT_OVERRIDE:-}" ]; then
      echo "Setting api_endpoint_overrides/edgenetwork to $EDGE_NETWORK_API_ENDPOINT_OVERRIDE"
      gcloud config set api_endpoint_overrides/edgenetwork $EDGE_NETWORK_API_ENDPOINT_OVERRIDE
    fi

    gcloud edge-cloud container clusters describe $CLUSTER_NAME --location $LOCATION \
        --project $FLEET_PROJECT_ID

    if [ $? -eq 0 ]; then
      echo "Cluster already created, skipping to next step."
    else
      echo "Creating cluster"
      gcloud edge-cloud container clusters create $CLUSTER_NAME \
          --control-plane-node-location=$NODE_LOCATION \
          --control-plane-node-count=$NODE_COUNT \
          --cluster-ipv4-cidr=$CLUSTER_IPV4_CIDR \
          --services-ipv4-cidr=$SERVICES_IPV4_CIDR \
          --external-lb-ipv4-address-pools=$EXTERNAL_LOAD_BALANCER_IPV4_ADDRESS_POOLS \
          --control-plane-shared-deployment-policy=ALLOWED \
          --location=$LOCATION \
          --project=$FLEET_PROJECT_ID \
          --release-channel=NONE \
          --version $CLUSTER_VERSION
          # --offline-reboot-ttl=7d \

      [[ $? -ne 0 ]] && die "Failure from gcloud edge-cloud container clusters ..."

    fi

    if [[ -z "${MAINTENANCE_WINDOW_START}" || ${MAINTENANCE_WINDOW_END} || \
            ${MAINTENANCE_WINDOW_RECURRENCE} ]]; then
      echo "All maintenance window fields are not set, skipping"
      echo "MAINTENANCE_WINDOW_START=${MAINTENANCE_WINDOW_START}"
      echo "MAINTENANCE_WINDOW_END=${MAINTENANCE_WINDOW_END}"
      echo "MAINTENANCE_WINDOW_RECURRENCE=${MAINTENANCE_WINDOW_RECURRENCE}"
    else
      gcloud edge-cloud container clusters update $CLUSTER_NAME \
          --project=$FLEET_PROJECT_ID \
          --location=$LOCATION \
          --maintenance-window-start=$MAINTENANCE_WINDOW_START \
          --maintenance-window-end=$MAINTENANCE_WINDOW_END \
          --maintenance-window-recurrence=$MAINTENANCE_WINDOW_RECURRENCE
      [[ $? -ne 0 ]] && die "Maintenance window update failed"
    fi

    gcloud edge-cloud networking zones init $NODE_LOCATION \
      --project=$MACHINE_PROJECT_ID \
      --location=$LOCATION

    [[ $? -ne 0 ]] && die "Zone network failed to initialize"

    for vlan in $(echo $SUBNET_VLANS | csvtool transpose -); do
      EXISTING_VLAN=$(gcloud edge-cloud networking subnets list --location $LOCATION \
          --zone $NODE_LOCATION --project $MACHINE_PROJECT_ID \
          --filter="VLANID=$vlan" --format="json")

      [[ $? -ne 0 ]] && die "Unable to query for subnets"

      if [ "$EXISTING_VLAN" = "[]" ]; then
        gcloud edge-cloud networking subnets create "network-$vlan" \
            --vlan-id=$vlan \
            --network=default \
            --location=$LOCATION \
            --zone=$NODE_LOCATION \
            --project $MACHINE_PROJECT_ID
        [[ $? -ne 0 ]] && die "Subnet creation failed"
      else
        echo "VLAN $vlan already exists"
      fi
    done

    export KUBECONFIG="$(pwd)/gateway-kubeconfig"
    gcloud container fleet memberships get-credentials $CLUSTER_NAME --project $FLEET_PROJECT_ID

    gsutil cp gs://$CLUSTER_INTENT_BUCKET/apply-spec.yaml.template .

    envsubst < apply-spec.yaml.template > apply-spec.yaml

    gcloud secrets versions access latest --secret=$GIT_TOKEN_SECRETS_MANAGER_NAME \
        --project $SECRETS_PROJECT_ID >> $(pwd)/git-creds

    kubectl create ns config-management-system --dry-run=client -o yaml | kubectl apply -f -

    kubectl create secret generic git-creds --namespace="config-management-system" \
        --from-literal=username=default --from-file=token=$(pwd)/git-creds \
        --dry-run=client -o yaml | kubectl apply -f -

    gcloud beta container fleet config-management apply --membership=$CLUSTER_NAME \
        --config=./apply-spec.yaml --project $FLEET_PROJECT_ID

    if [ -z "${SKIP_HEALTH_CHECK}" ]; then
      count=0
      max_retries=240 # 1200s/20min
      echo "Waiting for health check resource to be created"
      while [[ ${count} -lt ${max_retries} ]]; do
        kubectl get healthchecks.validator.gdc.gke.io/default >/dev/null 2>&1 && break
        echo -n .
        sleep 5
        ((count++))
      done
      [[ ${count} -ge ${max_retries} ]] && die "Health check resource not created after 20min"

      kubectl wait healthchecks.validator.gdc.gke.io/default --for condition=PlatformHealthy \
          --timeout=20m || die "Platform is not healthy after 20m"
      kubectl wait healthchecks.validator.gdc.gke.io/default --for condition=WorkloadsHealthy \
          --timeout=2h || die "Workloads are not healthy after 2h"
    fi
    
    if [[ -n "${ZONE_NAME_FROM_SOT}" ]]; then
      echo "Zone name is defined in SOT... skipping zone signal completion."
    else
      zone_signal_complete "projects/${MACHINE_PROJECT_ID}/locations/${LOCATION}/zones/${STORE_ID}"
    fi

    echo "Cluster Creation Succeeded: $CLUSTER_NAME"

  env:
  - 'STORE_ID=$_STORE_ID'
  - 'ZONE=$_ZONE'
  - 'EDGE_CONTAINER_API_ENDPOINT_OVERRIDE=$_EDGE_CONTAINER_API_ENDPOINT_OVERRIDE'
  - 'EDGE_NETWORK_API_ENDPOINT_OVERRIDE=$_EDGE_NETWORK_API_ENDPOINT_OVERRIDE'
  - 'GKEHUB_API_ENDPOINT_OVERRIDE=$_GKEHUB_API_ENDPOINT_OVERRIDE'
  - 'HARDWARE_MANAGMENT_API_ENDPOINT_OVERRIDE=$_HARDWARE_MANAGMENT_API_ENDPOINT_OVERRIDE'
  - 'CLUSTER_INTENT_BUCKET=$_CLUSTER_INTENT_BUCKET'
  - 'SOURCE_OF_TRUTH_REPO=$_SOURCE_OF_TRUTH_REPO'
  - 'SOURCE_OF_TRUTH_BRANCH=$_SOURCE_OF_TRUTH_BRANCH'
  - 'SOURCE_OF_TRUTH_PATH=$_SOURCE_OF_TRUTH_PATH'
  - 'GIT_SECRET_ID=$_GIT_SECRET_ID'
  - 'GIT_SECRETS_PROJECT_ID=$_GIT_SECRETS_PROJECT_ID'
timeout: 14400s
options:
  logging: CLOUD_LOGGING_ONLY
